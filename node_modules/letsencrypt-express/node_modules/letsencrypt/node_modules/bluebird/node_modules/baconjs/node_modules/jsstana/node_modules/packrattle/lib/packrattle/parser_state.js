"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

exports.newParserState = newParserState;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _match = require("./match");

var _match2 = _interopRequireDefault(_match);

/*
 * given an absolute position within text, calculate the line # and the
 * horizontal offset within that line.
 */
function calculateLine(text, pos) {
  var lineNumber = 0;
  var startOfLine = 0;
  for (var i = 0; i < pos; i++) {
    if (text[i] == "\n") {
      startOfLine = i + 1;
      lineNumber++;
    }
  }

  var endOfLine = pos;
  while (endOfLine < text.length && text[endOfLine] != "\n") endOfLine++;

  return { lineNumber: lineNumber, startOfLine: startOfLine, endOfLine: endOfLine, xpos: pos - startOfLine };
}

/*
 * span of text corresponding to a matching segment of the string.
 * this is effectively immutable.
 */

var Span = (function () {
  function Span(text, start, end) {
    _classCallCheck(this, Span);

    this.text = text;
    this.start = start;
    this.end = end;
    if (this.end == this.start) this.end++;
    this._startLine = null;
    this._endLine = null;
  }

  /*
   * parser state, used internally.
   * - pos: current text position (next char to parse)
   * - startpos: text position at the start of the current parser
   * - depth: debugging indicator: how nested is this parser
   * - parser: which parser is currently operating
   * - engine: link back to whatever engine executed me
   */

  _createClass(Span, [{
    key: "toString",
    value: function toString() {
      return "Span(" + this.start + " -> " + this.end + ")";
    }
  }, {
    key: "toSquiggles",

    /*
     * find the full line corresponding to the beginning of this span, and "mark"
     * the span with `~` characters. returns a two-element array containing the
     * full line and the line with squiggles.
     */
    value: function toSquiggles() {
      // for a span covering multiple lines, just show the first line.
      var endxpos = this.endLine.lineNumber != this.startLine.lineNumber ? this.startLine.endOfLine : this.endLine.xpos;
      if (endxpos == this.startLine.xpos) endxpos++;

      var squiggles = "";
      for (var i = 0; i < this.startLine.xpos; i++) {
        squiggles += " ";
      }for (var i = this.startLine.xpos; i < endxpos; i++) {
        squiggles += "~";
      }return [this.text.slice(this.startLine.startOfLine, this.startLine.endOfLine), squiggles];
    }

    /*
     * return a segment of the line "around" (left and right of) the start of
     * this span.
     */
  }, {
    key: "around",
    value: function around(width) {
      var line = this.startLine;
      var text = this.text.slice(line.startOfLine, line.endOfLine);

      var left = line.xpos - width;
      var right = line.xpos + width;
      if (left < 0) left = 0;
      if (right >= line.length) right = text.length - 1;
      return text.slice(left, line.xpos) + "[" + (text[line.xpos] || "") + "]" + text.slice(line.xpos + 1, right + 1);
    }
  }, {
    key: "startLine",
    get: function get() {
      if (this._startLine) return this._startLine;
      this._startLine = calculateLine(this.text, this.start);
      return this._startLine;
    }
  }, {
    key: "endLine",
    get: function get() {
      if (this._endLine) return this._endLine;
      this._endLine = calculateLine(this.text, this.end);
      return this._endLine;
    }
  }]);

  return Span;
})();

exports.Span = Span;

var ParserState = (function () {
  function ParserState() {
    _classCallCheck(this, ParserState);
  }

  _createClass(ParserState, [{
    key: "toString",

    // empty for speed. always use one of the methods or factories.
    value: function toString() {
      return "ParserState[" + this.startpos + " -> " + this.pos + "](depth=" + this.depth + ", parser.id=" + this.parser.id + ")";
    }

    /*
     * return a new ParserState with the position advanced `n` places.
     * `startpos` is unchanged.
     */
  }, {
    key: "advance",
    value: function advance(n) {
      var rv = new ParserState();
      rv.pos = this.pos + n;
      rv.startpos = this.pos;
      rv.depth = this.depth;
      rv.parser = this.parser;
      rv.engine = this.engine;
      return rv;
    }

    /*
     * jump to a new parser, marking the state as one-deeper and a new parser id.
     */
  }, {
    key: "next",
    value: function next(parser) {
      var rv = new ParserState();
      rv.pos = this.pos;
      rv.startpos = this.pos;
      rv.depth = this.depth + 1;
      rv.parser = parser;
      rv.engine = this.engine;
      return rv;
    }

    /*
     * return a state with a span covering both this state and another.
     */
  }, {
    key: "merge",
    value: function merge(other) {
      var rv = new ParserState();
      rv.depth = this.depth;
      rv.parser = this.parser;
      rv.engine = this.engine;
      rv.startpos = Math.min(this.startpos, other.startpos);
      rv.pos = Math.max(this.pos, other.pos);
      return rv;
    }

    /*
     * return the covering span of the current match.
     */
  }, {
    key: "span",
    value: function span() {
      return new Span(this.engine.text, this.startpos, this.pos);
    }

    /*
     * convenient (unique) string id
     */
  }, {
    key: "schedule",

    /*
     * schedule another parser to run, and return the ResultSet that will
     * eventually contain the result.
     */
    value: function schedule(parser, condition) {
      return this.engine.schedule(this.next(parser), condition);
    }
  }, {
    key: "success",
    value: function success(value) {
      var commit = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

      return new _match2["default"](true, this, { value: value, commit: commit });
    }
  }, {
    key: "failure",
    value: function failure(value) {
      var commit = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

      // use "Expected (current parser)" as the default failure message.
      var generated = false;
      if (!value && this.parser) {
        value = "Expected " + this.parser.inspect();
        generated = true;
      }
      return new _match2["default"](false, this, { value: value, commit: commit, generated: generated });
    }
  }, {
    key: "id",
    get: function get() {
      return this.parser ? this.parser.id + ":" + this.pos : "start";
    }

    /*
     * current text being parsed
     */
  }, {
    key: "text",
    get: function get() {
      return this.engine.text;
    }
  }]);

  return ParserState;
})();

exports.ParserState = ParserState;

function newParserState(engine) {
  var rv = new ParserState();
  rv.pos = 0;
  rv.startpos = 0;
  rv.depth = 0;
  rv.parser = null;
  rv.engine = engine;
  return rv;
}
//# sourceMappingURL=parser_state.js.map