{"version":3,"sources":["../../src/packrattle/simple.js"],"names":[],"mappings":"AAAA,YAAY,CAAC;;;;;;;;;sBAEa,UAAU;;;;;;;AAO7B,IAAM,GAAG,GAAG,YAPV,SAAS,EAOW,KAAK,EAAE,UAAC,KAAK,EAAE,OAAO,EAAK;AACtD,SAAO,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,OAAO,EAAE,GAAG,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;CACjF,CAAC,CAAC;;;;AAGI,IAAM,MAAM,GAAG,YAZb,SAAS,EAYc,QAAQ,EAAE,UAAC,KAAK,EAAE,OAAO,EAAK;AAC5D,SAAO,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC;CACxC,CAAC,CAAC;;;;;AAGI,SAAS,OAAO,CAAC,KAAK,EAAE;AAC7B,SAAO,YAlBA,SAAS,EAkBC,SAAS,EAAE,UAAC,KAAK,EAAE,OAAO,EAAK;AAC9C,WAAO,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;GACnC,CAAC,CAAC;CACJ;;;;AAGM,SAAS,MAAM,CAAC,CAAC,EAAE;AACxB,MAAM,GAAG,GAAG,CAAC,CAAC,MAAM,CAAC;AACrB,SAAO,YA1BA,SAAS,EA0BC,QAAQ,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,QAAQ,QAAM,CAAC,MAAG,EAAE,EAAE,UAAC,KAAK,EAAE,OAAO,EAAK;AACtF,QAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC;AAC7D,WAAO,CAAC,GAAG,CAAC,OAAO,IAAI,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;GACnF,CAAC,CAAC;CACJ;;;;AAGM,SAAS,KAAK,CAAC,CAAC,EAAE;AACvB,MAAM,CAAC,GAAG,CAAC,CAAC,UAAU,GAAG,GAAG,GAAG,EAAE,CAAC;AAClC,MAAM,CAAC,GAAG,CAAC,CAAC,SAAS,GAAG,GAAG,GAAG,EAAE,CAAC;AACjC,MAAM,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC,MAAM,GAAI,GAAG,GAAG,CAAC,CAAC,MAAM,AAAC,CAAA;AAC/D,MAAM,EAAE,GAAG,IAAI,MAAM,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;AACrC,SAAO,YAtCA,SAAS,EAsCC,OAAO,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,QAAQ,EAAE,CAAC,CAAC,QAAQ,EAAE,EAAE,EAAE,UAAC,KAAK,EAAE,OAAO,EAAK;AACzF,QAAM,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;AAC/C,WAAO,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;GAC1E,CAAC,CAAC;CACJ","file":"simple.js","sourcesContent":["\"use strict\";\n\nimport { newParser } from \"./parser\";\n\n/*\n * simple \"building block\" parsers.\n */\n\n// matches the end of the string.\nexport const end = newParser(\"end\", (state, results) => {\n  results.add(state.pos == state.text.length ? state.success() : state.failure());\n});\n\n// never matches anything.\nexport const reject = newParser(\"reject\", (state, results) => {\n  results.add(state.failure(\"rejected\"));\n});\n\n// always matches without consuming input and yields the given value.\nexport function succeed(value) {\n  return newParser(\"succeed\", (state, results) => {\n    results.add(state.success(value));\n  });\n}\n\n// matches a literal string.\nexport function string(s) {\n  const len = s.length;\n  return newParser(\"string\", { cacheable: true, describe: `'${s}'` }, (state, results) => {\n    const segment = state.text.slice(state.pos, state.pos + len);\n    results.add(segment == s ? state.advance(len).success(segment) : state.failure());\n  });\n}\n\n// matches a regex.\nexport function regex(r) {\n  const i = r.ignoreCase ? \"i\" : \"\";\n  const m = r.multiline ? \"m\" : \"\";\n  const source = r.source[0] == \"^\" ? r.source : (\"^\" + r.source)\n  const r2 = new RegExp(source, i + m);\n  return newParser(\"regex\", { cacheable: true, describe: r.toString() }, (state, results) => {\n    const m = r2.exec(state.text.slice(state.pos));\n    results.add(m ? state.advance(m[0].length).success(m) : state.failure());\n  });\n}\n"]}