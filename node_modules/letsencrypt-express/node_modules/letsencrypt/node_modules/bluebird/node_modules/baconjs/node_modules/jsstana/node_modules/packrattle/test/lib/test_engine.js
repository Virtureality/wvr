"use strict";

var pr = require("../../lib");
var util = require("util");

require("should");
require("source-map-support").install();

describe("Engine", function () {
  describe("implicitly", function () {
    it("turns strings into parsers", function () {
      var p = pr.chain("abc", "123", function (a, b) {
        return b + a;
      });
      p.run("abc123").should.eql("123abc");
    });

    it("turns regexes into parsers", function () {
      var p = pr.chain("wut", /\d+/, function (a, b) {
        return a + ":" + b[0];
      });
      p.run("wut999").should.eql("wut:999");
    });

    it("strings together a chained sequence", function () {
      var p = ["abc", pr.drop(/\d+/), "xyz"];
      var m = pr(p).execute("abc11xyz");
      m.value.should.eql(["abc", "xyz"]);
      m.state.pos.should.eql(8);
    });
  });

  describe("lazily resolves", function () {
    it("a nested parser", function () {
      var p = pr.chain(pr.string(":"), function () {
        return pr.regex(/\w+/);
      }, function (a, b) {
        return [a, b];
      });
      var rv = p.execute(":hello");
      rv.state.pos.should.equal(6);
      rv.value[0].should.eql(":");
      rv.value[1][0].should.eql("hello");
    });

    it("only once", function () {
      var count = 0;
      var lazy = function lazy() {
        count++;
        return pr.regex(/\w+/);
      };
      var p1 = pr.chain(":", lazy, function (a, b) {
        return [a, b[0].toUpperCase()];
      });
      var p2 = pr.chain(":h", lazy, function (a, b) {
        return [a, b[0].toUpperCase()];
      });
      var p = pr.alt(pr.chain(p1, "?", function (a, b) {
        return b;
      }), p2);

      p.run(":hello").should.eql([":h", "ELLO"]);
      count.should.equal(1);
      p.run(":g?").should.eql("?");
      count.should.equal(1);
      p.run(":howdy").should.eql([":h", "OWDY"]);
      count.should.equal(1);
    });

    it("supports drop for lazy parsers", function () {
      var p = pr.drop(function () {
        return "abc";
      });
      var m = p.execute("abc");
      (m.value == null).should.eql(true);
      m.state.pos.should.eql(3);
    });
  });

  it("only executes a parser once per string/position", function () {
    var count = 0;

    var dupe = pr("dupe").onMatch(function (x) {
      count++;
      return x;
    });
    var p = pr.alt(pr.chain(dupe, "1", function (a, b) {
      return b;
    }), pr.chain(dupe, "2", function (a, b) {
      return b;
    }));

    p.run("dupe2").should.eql("2");
    count.should.eql(1);
  });
});
//# sourceMappingURL=test_engine.js.map