"use strict";

// pretend like js has a collections library.
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function exists(array, f) {
  for (var i = 0; i < array.length; i++) {
    if (f(array[i])) return true;
  }return false;
}

/*
 * debug the parser by plotting a directed graph of parse nodes as it works
 * on a string.
 */

var DebugGraph = (function () {
  function DebugGraph() {
    _classCallCheck(this, DebugGraph);

    this.nodes = {};
    this.edges = [];
    this.success = false;
    this.failure = false;
  }

  _createClass(DebugGraph, [{
    key: "addEdge",
    value: function addEdge(from, to) {
      this.edges.push({ from: from, to: to });
      if (this.nodes[from]) this.nodes[from].children.push(to);
      if (this.nodes[to]) this.nodes[to].parents.push(from);
      if (to == "success") this.success = true;
      if (to == "failure") this.failure = true;
    }
  }, {
    key: "addNode",
    value: function addNode(name, parser, span) {
      var node = { parser: parser, span: span, parents: [], children: [] };
      this.edges.forEach(function (edge) {
        if (edge.from == name) node.children.push(edge.to);
        if (edge.to == name) node.parents.push(edge.from);
      });
      this.nodes[name] = node;
    }
  }, {
    key: "markFailure",
    value: function markFailure(name) {
      this.nodes[name].failure = true;
    }

    // filter out parsers with certain names
  }, {
    key: "filterOut",
    value: function filterOut() {
      var _this = this;

      for (var _len = arguments.length, names = Array(_len), _key = 0; _key < _len; _key++) {
        names[_key] = arguments[_key];
      }

      var nodesToRemove = [];

      Object.keys(this.nodes).forEach(function (name) {
        var node = _this.nodes[name];
        if (names.indexOf(node.parser.name) < 0) return;

        var edgesToRemove = [];
        // skip deleting a node that would make the graph bushier
        if (node.parents.length > 1 && node.children.length > 1) return;

        node.parents.forEach(function (p) {
          edgesToRemove.push({ from: p, to: name });
          if (_this.nodes[p]) _this.nodes[p].children = _this.nodes[p].children.filter(function (c) {
            return c != name;
          });
        });
        node.children.forEach(function (c) {
          edgesToRemove.push({ from: name, to: c });
          if (_this.nodes[c]) _this.nodes[c].parents = _this.nodes[c].parents.filter(function (p) {
            return p != name;
          });
        });
        node.parents.forEach(function (p) {
          node.children.forEach(function (c) {
            _this.addEdge(p, c);
          });
        });
        delete _this.nodes[name];

        _this.edges = _this.edges.filter(function (edge) {
          return !exists(edgesToRemove, function (e) {
            return e.from == edge.from && e.to == edge.to;
          });
        });
      });
    }
  }, {
    key: "toDot",
    value: function toDot() {
      var _this2 = this;

      var maxLength = arguments.length <= 0 || arguments[0] === undefined ? 40 : arguments[0];

      this.filterOut("map", "filter", "drop", "optional");

      var data = ["digraph packrattle {", "  node [fontname=Courier];"];
      data.push("");
      this.edges.forEach(function (edge) {
        data.push("  \"" + edge.from + "\" -> \"" + edge.to + "\";");
      });
      data.push("");
      Object.keys(this.nodes).forEach(function (name) {
        var node = _this2.nodes[name];
        if (!node.parser) return;
        var description = node.parser.inspect();
        if (description.length > maxLength) description = description.slice(0, maxLength) + "...";
        description = description.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
        var around = node.span.around(4).replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
        var label = "label=\"@" + node.span.start + ": " + description + "\\n'" + around + "'\"";
        var style = node.failure ? ["style=filled", "fillcolor=pink"] : [];
        var attrs = [label, "shape=rect"].concat(style).join(", ");
        data.push("  \"" + name + "\" [" + attrs + "];");
      });
      data.push("");
      data.push("  \"start\" [shape=circle, style=filled, fillcolor=yellow];");
      if (this.success) data.push("  \"success\" [shape=rect, style=filled, fillcolor=green];");
      if (this.failure) data.push("  \"failure\" [shape=rect, style=filled, fillcolor=red];");
      data.push("}");
      return data.join("\n") + "\n";
    }
  }]);

  return DebugGraph;
})();

exports["default"] = DebugGraph;
module.exports = exports["default"];
//# sourceMappingURL=debug_graph.js.map