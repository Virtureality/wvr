{"version":3,"sources":["../../src/packrattle/parser_state.js"],"names":[],"mappings":"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","file":"parser_state.js","sourcesContent":["\"use strict\";\n\nimport Match from \"./match\";\n\n/*\n * given an absolute position within text, calculate the line # and the\n * horizontal offset within that line.\n */\nfunction calculateLine(text, pos) {\n  let lineNumber = 0;\n  let startOfLine = 0;\n  for (let i = 0; i < pos; i++) {\n    if (text[i] == \"\\n\") {\n      startOfLine = i + 1;\n      lineNumber++;\n    }\n  }\n\n  let endOfLine = pos;\n  while (endOfLine < text.length && text[endOfLine] != \"\\n\") endOfLine++;\n\n  return { lineNumber, startOfLine, endOfLine, xpos: pos - startOfLine };\n}\n\n/*\n * span of text corresponding to a matching segment of the string.\n * this is effectively immutable.\n */\nexport class Span {\n  constructor(text, start, end) {\n    this.text = text;\n    this.start = start;\n    this.end = end;\n    if (this.end == this.start) this.end++;\n    this._startLine = null;\n    this._endLine = null;\n  }\n\n  toString() {\n    return `Span(${this.start} -> ${this.end})`;\n  }\n\n  get startLine() {\n    if (this._startLine) return this._startLine;\n    this._startLine = calculateLine(this.text, this.start);\n    return this._startLine;\n  }\n\n  get endLine() {\n    if (this._endLine) return this._endLine;\n    this._endLine = calculateLine(this.text, this.end);\n    return this._endLine;\n  }\n\n  /*\n   * find the full line corresponding to the beginning of this span, and \"mark\"\n   * the span with `~` characters. returns a two-element array containing the\n   * full line and the line with squiggles.\n   */\n  toSquiggles() {\n    // for a span covering multiple lines, just show the first line.\n    let endxpos = (this.endLine.lineNumber != this.startLine.lineNumber) ? this.startLine.endOfLine : this.endLine.xpos;\n    if (endxpos == this.startLine.xpos) endxpos++;\n\n    let squiggles = \"\"\n    for (let i = 0; i < this.startLine.xpos; i++) squiggles += \" \";\n    for (let i = this.startLine.xpos; i < endxpos; i++) squiggles += \"~\";\n    return [ this.text.slice(this.startLine.startOfLine, this.startLine.endOfLine), squiggles ];\n  }\n\n  /*\n   * return a segment of the line \"around\" (left and right of) the start of\n   * this span.\n   */\n  around(width) {\n    const line = this.startLine;\n    const text = this.text.slice(line.startOfLine, line.endOfLine);\n\n    let left = line.xpos - width;\n    let right = line.xpos + width;\n    if (left < 0) left = 0;\n    if (right >= line.length) right = text.length - 1;\n    return text.slice(left, line.xpos) + \"[\" + (text[line.xpos] || \"\") + \"]\" + text.slice(line.xpos + 1, right + 1);\n  }\n}\n\n\n/*\n * parser state, used internally.\n * - pos: current text position (next char to parse)\n * - startpos: text position at the start of the current parser\n * - depth: debugging indicator: how nested is this parser\n * - parser: which parser is currently operating\n * - engine: link back to whatever engine executed me\n */\nexport class ParserState {\n  constructor() {\n    // empty for speed. always use one of the methods or factories.\n  }\n\n  toString() {\n    return `ParserState[${this.startpos} -> ${this.pos}](depth=${this.depth}, parser.id=${this.parser.id})`;\n  }\n\n  /*\n   * return a new ParserState with the position advanced `n` places.\n   * `startpos` is unchanged.\n   */\n  advance(n) {\n    const rv = new ParserState();\n    rv.pos = this.pos + n;\n    rv.startpos = this.pos;\n    rv.depth = this.depth;\n    rv.parser = this.parser;\n    rv.engine = this.engine;\n    return rv;\n  }\n\n  /*\n   * jump to a new parser, marking the state as one-deeper and a new parser id.\n   */\n  next(parser) {\n    const rv = new ParserState();\n    rv.pos = this.pos;\n    rv.startpos = this.pos;\n    rv.depth = this.depth + 1;\n    rv.parser = parser;\n    rv.engine = this.engine;\n    return rv;\n  }\n\n  /*\n   * return a state with a span covering both this state and another.\n   */\n  merge(other) {\n    const rv = new ParserState();\n    rv.depth = this.depth;\n    rv.parser = this.parser;\n    rv.engine = this.engine;\n    rv.startpos = Math.min(this.startpos, other.startpos);\n    rv.pos = Math.max(this.pos, other.pos);\n    return rv;\n  }\n\n  /*\n   * return the covering span of the current match.\n   */\n  span() {\n    return new Span(this.engine.text, this.startpos, this.pos);\n  }\n\n  /*\n   * convenient (unique) string id\n   */\n  get id() {\n    return this.parser ? `${this.parser.id}:${this.pos}` : \"start\";\n  }\n\n  /*\n   * current text being parsed\n   */\n  get text() {\n    return this.engine.text;\n  }\n\n  /*\n   * schedule another parser to run, and return the ResultSet that will\n   * eventually contain the result.\n   */\n  schedule(parser, condition) {\n    return this.engine.schedule(this.next(parser), condition);\n  }\n\n  success(value, commit = false) {\n    return new Match(true, this, { value, commit });\n  }\n\n  failure(value, commit = false) {\n    // use \"Expected (current parser)\" as the default failure message.\n    let generated = false;\n    if (!value && this.parser) {\n      value = \"Expected \" + this.parser.inspect();\n      generated = true;\n    }\n    return new Match(false, this, { value, commit, generated });\n  }\n}\n\n\nexport function newParserState(engine) {\n  const rv = new ParserState();\n  rv.pos = 0;\n  rv.startpos = 0;\n  rv.depth = 0;\n  rv.parser = null;\n  rv.engine = engine;\n  return rv;\n}\n"]}