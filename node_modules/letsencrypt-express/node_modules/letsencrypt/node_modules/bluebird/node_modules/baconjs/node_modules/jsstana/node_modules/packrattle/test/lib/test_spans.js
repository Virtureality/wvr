"use strict";

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

var pr = require("../../lib");
var util = require("util");

require("should");
require("source-map-support").install();

describe("Parser.onMatch spans", function () {
  it("cover a string", function () {
    var p = pr("abc").onMatch(function (m, span) {
      return span;
    });
    var rv = p.execute("abc");
    rv.ok.should.eql(true);
    rv.value.start.should.eql(0);
    rv.value.end.should.eql(3);
  });

  it("cover a regex", function () {
    var p = pr(/ab+c/).onMatch(function (m, span) {
      return span;
    });
    var rv = p.execute("abc");
    rv.ok.should.eql(true);
    rv.value.start.should.eql(0);
    rv.value.end.should.eql(3);
  });

  it("survive an alt", function () {
    var p = pr.alt("xyz", pr("abc").onMatch(function (m, span) {
      return span;
    }));
    var rv = p.execute("abc");
    rv.ok.should.eql(true);
    rv.value.start.should.eql(0);
    rv.value.end.should.eql(3);
  });

  it("cover an alt", function () {
    var p = pr.alt("xyz", "abc").onMatch(function (m, span) {
      return span;
    });
    var rv = p.execute("abc");
    rv.ok.should.eql(true);
    rv.value.start.should.eql(0);
    rv.value.end.should.eql(3);
  });

  it("cover a sequence", function () {
    var p = pr.seq("xyz", "abc").onMatch(function (m, span) {
      return span;
    });
    var rv = p.execute("xyzabc");
    rv.ok.should.eql(true);
    rv.value.start.should.eql(0);
    rv.value.end.should.eql(6);
  });

  it("cover a combination", function () {
    var p = pr.seq("abc", pr.optional(/\s+/), pr.alt(/\d+/, pr.seq("x", /\d+/, "x").onMatch(function (m, span) {
      return span;
    })), pr.optional("?")).onMatch(function (m, span) {
      return [m, span];
    });
    var rv = p.execute("abc x99x?");
    rv.ok.should.eql(true);

    var _rv$value = _slicedToArray(rv.value, 2);

    var m = _rv$value[0];
    var state = _rv$value[1];

    state.start.should.eql(0);
    state.end.should.eql(9);
    m[2].start.should.eql(4);
    m[2].end.should.eql(8);
  });

  it("crosses line boundaries", function () {
    var p = pr.seq(/\w+/, /\s+/, pr("line\nbreak").onMatch(function (m, span) {
      return span;
    }), /\s+/, /\w+/);
    var rv = p.execute("hello line\nbreak ok");
    rv.ok.should.eql(true);
    var span = rv.value[2];
    span.start.should.eql(6);
    span.startLine.lineNumber.should.eql(0);
    span.startLine.xpos.should.eql(6);
    span.end.should.eql(16);
    span.endLine.lineNumber.should.eql(1);
    span.endLine.xpos.should.eql(5);
    span.toSquiggles().should.eql(["hello line", "      ~~~~"]);
  });

  it("marks errors", function () {
    var p = pr.seq(pr(/\w+/).commit(), /\d+/);
    var rv = p.execute("hello???");
    rv.ok.should.eql(false);
    var span = rv.state.span();
    span.toSquiggles().should.eql(["hello???", "     ~"]);
    span.start.should.eql(5);
    span.end.should.eql(6);
  });

  it("survives chains of maps", function () {
    var p = pr.seq(/[a-z]+/, /\d+/).map(function (match, span) {
      return match[0][0] + match[1][0];
    }).map(function (match, span) {
      return match.toUpperCase() + span.end;
    });
    var rv = p.execute("what34");
    rv.ok.should.eql(true);
    rv.value.should.eql("WHAT346");
    var span = rv.state.span();
    span.start.should.eql(0);
    span.end.should.eql(6);
  });
});
//# sourceMappingURL=test_spans.js.map