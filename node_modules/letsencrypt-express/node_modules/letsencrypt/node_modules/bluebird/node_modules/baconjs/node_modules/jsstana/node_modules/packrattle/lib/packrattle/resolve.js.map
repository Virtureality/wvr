{"version":3,"sources":["../../src/packrattle/resolve.js"],"names":[],"mappings":"AAAA,YAAY,CAAC;;;;;;qBAoBW,OAAO;;;;AAjB/B,IAAI,UAAU,GAAG,IAAI,CAAC;AACtB,IAAI;AACF,QAAM,CAAC;CACR,CAAC,OAAO,KAAK,EAAE;AACd,YAAU,GAAG,KAAK,CAAC;CACpB;;AAED,IAAM,EAAE,GAAG,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,wBAAwB,CAAC;AAChE,IAAI,MAAM,GAAG,CAAC,CAAC;;;;;;;;;;AASA,SAAS,OAAO,CAAC,MAAM,EAAwB;MAAtB,aAAa,yDAAG,IAAI;;AAC1D,MAAI,OAAO,MAAM,IAAI,UAAU,EAAE;AAC/B,QAAI,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE;;AAEf,YAAM,EAAE,CAAC;AACT,YAAM,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC;KACrB;AACD,QAAM,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC,CAAC;AACtB,QAAI,aAAa,IAAI,aAAa,CAAC,EAAE,CAAC,EAAE;AACtC,YAAM,GAAG,aAAa,CAAC,EAAE,CAAC,CAAC;KAC5B,MAAM;AACL,YAAM,GAAG,MAAM,EAAE,CAAC;AAClB,UAAI,aAAa,EAAE,aAAa,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC;KAC/C;GACF;;;AAGD,MAAM,SAAS,GAAG,OAAO,CAAC,aAAa,CAAC,CAAC;AACzC,MAAM,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC;AAC1C,MAAM,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;;;AAGnC,MAAI,OAAO,MAAM,IAAI,QAAQ,EAAE,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;AAC9D,MAAI,OAAO,MAAM,IAAI,QAAQ,IAAI,MAAM,CAAC,WAAW,CAAC,IAAI,IAAI,QAAQ,EAAE,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;AACpG,MAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,MAAM,GAAG,SAAS,CAAC,GAAG,MAAA,CAAb,SAAS,qBAAQ,MAAM,EAAC,CAAC;;AAE7D,MAAI,EAAE,MAAM,YAAY,MAAM,CAAA,AAAC,EAAE,MAAM,IAAI,KAAK,CAAC,4BAA4B,GAAG,MAAM,CAAC,CAAC;AACxF,SAAO,MAAM,CAAC;CACf","file":"resolve.js","sourcesContent":["\"use strict\";\n\n// detect missing Symbol :(\nlet haveSymbol = true;\ntry {\n  Symbol;\n} catch (error) {\n  haveSymbol = false;\n}\n\nconst ID = haveSymbol ? Symbol(\"id\") : \"__packrattle_Symbol_id\";\nlet LazyId = 0;\n\n/*\n * convert a \"parser\" into an actual Parser object.\n * - could be a lazy function that evaluates to a Parser\n * - could be a simple data type like regex that is \"implicitly\" a Parser\n *\n * if you'd like te cache the results of function evaluations, pass an empty object as `functionCache`.\n */\nexport default function resolve(parser, functionCache = null) {\n  if (typeof parser == \"function\") {\n    if (!parser[ID]) {\n      // give every lazy parser an id so we can cache them.\n      LazyId++;\n      parser[ID] = LazyId;\n    }\n    const id = parser[ID];\n    if (functionCache && functionCache[id]) {\n      parser = functionCache[id];\n    } else {\n      parser = parser();\n      if (functionCache) functionCache[id] = parser;\n    }\n  }\n\n  // avoid 'require' loops.\n  const combiners = require(\"./combiners\");\n  const Parser = require(\"./parser\").Parser;\n  const simple = require(\"./simple\");\n\n  // implicits:\n  if (typeof parser == \"string\") parser = simple.string(parser);\n  if (typeof parser == \"object\" && parser.constructor.name == \"RegExp\") parser = simple.regex(parser);\n  if (Array.isArray(parser)) parser = combiners.seq(...parser);\n\n  if (!(parser instanceof Parser)) throw new Error(\"Unable to resolve parser: \" + parser);\n  return parser;\n}\n"]}