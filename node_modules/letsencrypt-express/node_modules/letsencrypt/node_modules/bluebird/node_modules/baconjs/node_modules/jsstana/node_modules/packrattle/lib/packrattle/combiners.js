"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

exports.chain = chain;
exports.seq = seq;
exports.seqIgnore = seqIgnore;
exports.alt = alt;
exports.drop = drop;
exports.optional = optional;
exports.check = check;
exports.commit = commit;
exports.not = not;
exports.repeat = repeat;
exports.repeatIgnore = repeatIgnore;
exports.repeatSeparated = repeatSeparated;
exports.reduce = reduce;

var _parser = require("./parser");

/*
 * chain together parsers p1 & p2 such that if p1 matches, p2 is executed on
 * the following state. if both match, `combiner` is called with the two
 * matched objects, to create a single match result.
 */

function chain(p1, p2, combiner) {
  return (0, _parser.newParser)("chain", {
    children: [p1, p2],
    describe: function describe(list) {
      return list[0] + " then " + list[1];
    }
  }, function (state, results, p1, p2) {
    state.schedule(p1).then(function (match1) {
      if (!match1.ok) {
        results.add(match1);
      } else {
        match1.state.schedule(p2).then(function (match2) {
          if (!match2.ok) {
            // no backtracking if the left match was commit()'d.
            results.add(match1.commit ? match2.setCommit() : match2);
          } else {
            var newState = match2.state.merge(match1.state);
            var value = combiner(match1.value, match2.value);
            results.add(newState.success(value, match1.commit || match2.commit));
          }
        });
      }
    });
  });
}

/*
 * chain together a series of parsers as in 'chain'. the match value is an
 * array of non-null match values from the inner parsers.
 */

function seq() {
  for (var _len = arguments.length, parsers = Array(_len), _key = 0; _key < _len; _key++) {
    parsers[_key] = arguments[_key];
  }

  return (0, _parser.newParser)("seq", {
    cacheable: true,
    children: parsers,
    describe: function describe(list) {
      return "[ " + list.join(", ") + " ]";
    }
  }, function (state, results) {
    for (var _len2 = arguments.length, parsers = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      parsers[_key2 - 2] = arguments[_key2];
    }

    var commit = false;

    function next(state, i) {
      var rv = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];

      if (i >= parsers.length) return results.add(state.success(rv, commit));
      var p = parsers[i];
      state.schedule(p).then(function (match) {
        // no backtracking if we commit()'d in this chain.
        if (!match.ok) return results.add(commit ? match.setCommit() : match);
        if (match.commit) commit = true;
        next(state.merge(match.state), i + 1, match.value != null ? rv.concat([match.value]) : rv);
      });
    }

    next(state, 0);
  });
}

/*
 * chain together a sequence of parsers. before each parser is checked, the
 * 'ignore' parser is optionally matched and thrown away. this is typicially
 * used for discarding whitespace in lexical parsing.
 */

function seqIgnore(ignore) {
  var newseq = [];

  for (var _len3 = arguments.length, parsers = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    parsers[_key3 - 1] = arguments[_key3];
  }

  parsers.forEach(function (p) {
    newseq.push(drop(optional(ignore)));
    newseq.push(p);
  });
  return seq.apply(undefined, newseq);
}

/*
 * try each of these parsers, in order (starting from the same position),
 * looking for the first match.
 */

function alt() {
  for (var _len4 = arguments.length, parsers = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    parsers[_key4] = arguments[_key4];
  }

  return (0, _parser.newParser)("alt", {
    cacheable: true,
    children: parsers,
    describe: function describe(list) {
      return list.join(" or ");
    }
  }, function (state, results) {
    for (var _len5 = arguments.length, parsers = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
      parsers[_key5 - 2] = arguments[_key5];
    }

    var aborting = false;
    var count = 0;
    var fails = [];
    parsers.forEach(function (p) {
      state.schedule(p, function () {
        return !aborting;
      }).then(function (match) {
        if (match.ok) {
          results.add(match);
        } else {
          if (match.commit) {
            // skip other alternatives; dump error buffer.
            aborting = true;
            fails.splice(0, fails.length);
            return results.add(match);
          }
          fails.push(match);
        }
        // save up all the fails. if *all* of the alternatives fail, summarize it.
        count++;
        if (count == parsers.length) {
          if (count == fails.length) {
            results.add(state.failure());
          } else {
            fails.forEach(function (f) {
              return results.add(f);
            });
          }
        }
      });
    });
  });
}

/*
 * throw away the match value, equivalent to `map(null)`.
 */

function drop(p) {
  return (0, _parser.newParser)("drop", { wrap: p, cacheable: true }, function (state, results, p) {
    state.schedule(p).then(function (match) {
      results.add(match.ok ? match.withValue(null) : match);
    });
  });
}

/*
 * allow a parser to fail, and instead return a default value (the empty string
 * if no other value is provided).
 */

function optional(p, defaultValue) {
  return (0, _parser.newParser)("optional", {
    wrap: p,
    cacheable: typeof defaultValue == "string",
    extraCacheKey: defaultValue
  }, function (state, results, p) {
    state.schedule(p).then(function (match) {
      results.add(match);
      // unless we committed to p, always try the non-p case too.
      if (!match.commit) results.add(state.success(defaultValue));
    });
  });
}

/*
 * check that this parser matches, but don't advance our position in the
 * string. (perl calls this a zero-width lookahead.)
 */

function check(p) {
  return (0, _parser.newParser)("check", { wrap: p, cacheable: true }, function (state, results, p) {
    state.schedule(p).then(function (match) {
      results.add(match.ok ? match.withState(state) : match);
    });
  });
}

/*
 * if this parser matches, "commit" to this path and refuse to backtrack to
 * previous alternatives.
 */

function commit(p) {
  return (0, _parser.newParser)("commit", { wrap: p, cacheable: true }, function (state, results, p) {
    state.schedule(p).then(function (match) {
      results.add(match.ok ? match.setCommit() : match);
    });
  });
}

/*
 * succeed (with an empty match) if the inner parser fails; otherwise fail.
 */

function not(p) {
  return (0, _parser.newParser)("not", { wrap: p, cacheable: true }, function (state, results, p) {
    state.schedule(p).then(function (match) {
      results.add(match.ok ? state.failure(null, match.commit) : state.success("", match.commit));
    });
  });
}

/*
 * from 'min' to 'max' (inclusive) repetitions of a parser, returned as an
 * array. 'max' may be omitted to mean infinity.
 */

function repeat(p) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var min = options.min || 0;
  var max = options.max || Infinity;
  return (0, _parser.newParser)("repeat", {
    children: [p],
    describe: function describe(list) {
      return list.join() + (max == Infinity ? "{" + min + "+}" : "{" + min + ", " + max + "}");
    }
  }, function (state, results, p) {
    var count = 0;
    var list = [];

    function next(match, startingState) {
      var list = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
      var count = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];

      if (!match.ok) {
        // if we were committed, don't backtrack.
        if (match.commit) return results.add(match);
        // intentionally use the "last good state" from our repeating parser.
        return results.add(count >= min ? state.merge(startingState).success(list, match.commit) : state.failure());
      }
      count++;
      var newlist = match.value != null ? list.concat([match.value]) : list;
      if (count >= min) results.add(state.merge(match.state).success(newlist, match.commit));
      if (count < max) {
        // if a parser matches nothing, we could go on forever...
        if (match.state.pos == state.pos) {
          throw new Error("Repeating parser isn't making progress at position " + state.pos + ": " + p);
        }
        match.state.schedule(p).then(function (m) {
          return next(m, match.state, newlist, count);
        });
      }
    }

    state.schedule(p).then(function (m) {
      return next(m, state);
    });
  });
}

/*
 * like 'repeat', but each element may be optionally preceded by 'ignore',
 * which will be thrown away. this is usually used to remove leading
 * whitespace.
 */

function repeatIgnore(p, ignore, options) {
  return repeat(seq(optional(ignore).drop(), p).map(function (x) {
    return x[0];
  }), options);
}

/*
 * like 'repeat', but the repeated elements are separated by 'separator',
 * which is ignored.
 */

function repeatSeparated(p) {
  var separator = arguments.length <= 1 || arguments[1] === undefined ? "" : arguments[1];
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var min = options.min ? options.min - 1 : 0;
  var max = options.max ? options.max - 1 : Infinity;
  var p2 = seq(drop(separator), p).map(function (x) {
    return x[0];
  });
  return seq(p, repeat(p2, { min: min, max: max })).map(function (x) {
    return [x[0]].concat(x[1]);
  });
}

/*
 * convenience method for reducing the result of 'repeatSeparated', optionally
 * keeping the separator results. if 'accumulator' exists, it will transform
 * the initial result into an accumulator. if 'reducer' exists, it will be
 * used to progressively attach separators and new results.
 */

function reduce(p) {
  var separator = arguments.length <= 1 || arguments[1] === undefined ? "" : arguments[1];
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var first = options.first || function (x) {
    return [x];
  };
  var next = options.next || function (sum, sep, x) {
    return sum.push(x);
  };
  var min = options.min ? options.min - 1 : 0;
  var max = options.max ? options.max - 1 : Infinity;

  return seq(p, repeat(seq(separator, p), { min: min, max: max })).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2);

    var initial = _ref2[0];
    var remainder = _ref2[1];

    return [first(initial)].concat(remainder).reduce(function (sum, _ref3) {
      var _ref32 = _slicedToArray(_ref3, 2);

      var sep = _ref32[0];
      var item = _ref32[1];

      // 'sep' may have been dropped.
      if (item === undefined) {
        item = sep;
        sep = null;
      }
      return next(sum, sep, item);
    });
  });
}
//# sourceMappingURL=combiners.js.map