{"version":3,"sources":["../../src/packrattle/promise_set.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;IAaqB,UAAU;AAClB,WADQ,UAAU,GACH;QAAd,OAAO,yDAAG,EAAE;;0BADL,UAAU;;;AAG3B,QAAI,CAAC,MAAM,GAAG,IAAI,CAAC;AACnB,QAAI,CAAC,MAAM,GAAG,IAAI,CAAC;AACnB,QAAI,CAAC,SAAS,GAAG,IAAI,CAAC;AACtB,QAAI,CAAC,SAAS,GAAG,IAAI,CAAC;AACtB,QAAI,YAAS,GAAG,OAAO,YAAS,CAAC;GAClC;;eARkB,UAAU;;WAU1B,aAAC,KAAK,EAAE;AACT,UAAI,CAAC,IAAI,CAAC,MAAM,EAAE;AAChB,YAAI,CAAC,MAAM,GAAG,KAAK,CAAC;OACrB,MAAM;AACL,YAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;AACnC,YAAI,IAAI,CAAC,MAAM,IAAI,KAAK,IAAK,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,AAAC,EAAE,OAAO;;AAEtF,aAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC3C,cAAM,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACzB,cAAI,CAAC,IAAI,KAAK,IAAK,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,AAAC,EAAE,OAAO;SACzD;AACD,YAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;OACzB;;AAED,UAAI,IAAI,YAAS,EAAE,IAAI,YAAS,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,CAAC;;AAEnD,UAAI,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;AAC1C,UAAI,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,UAAA,CAAC;eAAI,CAAC,CAAC,KAAK,CAAC;OAAA,CAAC,CAAC;;AAE1D,aAAO,IAAI,CAAC;KACb;;;WAEG,cAAC,QAAQ,EAAE;AACb,UAAI,CAAC,IAAI,CAAC,SAAS,EAAE;AACnB,YAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;OAC3B,MAAM;AACL,YAAI,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;AACzC,YAAI,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;OAC/B;;AAED,UAAI,IAAI,CAAC,MAAM,EAAE,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AACvC,UAAI,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;;AAE/C,aAAO,IAAI,CAAC;KACb;;;SA5CkB,UAAU;;;qBAAV,UAAU","file":"promise_set.js","sourcesContent":["/*\n * a promise set is like a promise that can be resolved multiple times as\n * new results are added.\n *\n * it starts out with zero values and zero listeners.\n *\n * whenever a new value is posted, it's sent immediately to all listeners.\n * the value set can grow but never shrink; values must implement \"equals()\"\n * and redundant values will not be added.\n *\n * whenever a new listener is attached, it will immediately receive all current\n * values. if a new value is added later, it will receive the new value later.\n */\nexport default class PromiseSet {\n  constructor(options = {}) {\n    // optimize for the case of 1 value or 1 listener.\n    this.value0 = null;\n    this.values = null;\n    this.listener0 = null;\n    this.listeners = null;\n    this.debugger = options.debugger;\n  }\n\n  add(value) {\n    if (!this.value0) {\n      this.value0 = value;\n    } else {\n      if (!this.values) this.values = [];\n      if (this.value0 == value || (this.value0.equals && this.value0.equals(value))) return;\n      // babel bug: \"for (let v of this.values)\" causes it to try to refer to Symbol, which it fails to define.\n      for (let i = 0; i < this.values.length; i++) {\n        const v = this.values[i];\n        if (v == value || (v.equals && v.equals(value))) return;\n      }\n      this.values.push(value);\n    }\n\n    if (this.debugger) this.debugger(value.toString());\n\n    if (this.listener0) this.listener0(value);\n    if (this.listeners) this.listeners.forEach(f => f(value));\n\n    return this;\n  }\n\n  then(callback) {\n    if (!this.listener0) {\n      this.listener0 = callback;\n    } else {\n      if (!this.listeners) this.listeners = [];\n      this.listeners.push(callback);\n    }\n\n    if (this.value0) callback(this.value0);\n    if (this.values) this.values.forEach(callback);\n\n    return this;\n  }\n}\n"]}