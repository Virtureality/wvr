"use strict";

// detect missing Symbol :(
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = resolve;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

var haveSymbol = true;
try {
  Symbol;
} catch (error) {
  haveSymbol = false;
}

var ID = haveSymbol ? Symbol("id") : "__packrattle_Symbol_id";
var LazyId = 0;

/*
 * convert a "parser" into an actual Parser object.
 * - could be a lazy function that evaluates to a Parser
 * - could be a simple data type like regex that is "implicitly" a Parser
 *
 * if you'd like te cache the results of function evaluations, pass an empty object as `functionCache`.
 */

function resolve(parser) {
  var functionCache = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

  if (typeof parser == "function") {
    if (!parser[ID]) {
      // give every lazy parser an id so we can cache them.
      LazyId++;
      parser[ID] = LazyId;
    }
    var id = parser[ID];
    if (functionCache && functionCache[id]) {
      parser = functionCache[id];
    } else {
      parser = parser();
      if (functionCache) functionCache[id] = parser;
    }
  }

  // avoid 'require' loops.
  var combiners = require("./combiners");
  var Parser = require("./parser").Parser;
  var simple = require("./simple");

  // implicits:
  if (typeof parser == "string") parser = simple.string(parser);
  if (typeof parser == "object" && parser.constructor.name == "RegExp") parser = simple.regex(parser);
  if (Array.isArray(parser)) parser = combiners.seq.apply(combiners, _toConsumableArray(parser));

  if (!(parser instanceof Parser)) throw new Error("Unable to resolve parser: " + parser);
  return parser;
}

module.exports = exports["default"];
//# sourceMappingURL=resolve.js.map