{"version":3,"sources":["../../src/packrattle/combiners.js"],"names":[],"mappings":"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","file":"combiners.js","sourcesContent":["\"use strict\";\n\nimport { newParser } from \"./parser\";\n\n/*\n * chain together parsers p1 & p2 such that if p1 matches, p2 is executed on\n * the following state. if both match, `combiner` is called with the two\n * matched objects, to create a single match result.\n */\nexport function chain(p1, p2, combiner) {\n  return newParser(\"chain\", {\n    children: [ p1, p2 ],\n    describe: (list) => `${list[0]} then ${list[1]}`,\n  }, (state, results, p1, p2) => {\n    state.schedule(p1).then(match1 => {\n      if (!match1.ok) {\n        results.add(match1);\n      } else {\n        match1.state.schedule(p2).then(match2 => {\n          if (!match2.ok) {\n            // no backtracking if the left match was commit()'d.\n            results.add(match1.commit ? match2.setCommit() : match2);\n          } else {\n            const newState = match2.state.merge(match1.state);\n            const value = combiner(match1.value, match2.value);\n            results.add(newState.success(value, match1.commit || match2.commit));\n          }\n        });\n      }\n    });\n  });\n}\n\n/*\n * chain together a series of parsers as in 'chain'. the match value is an\n * array of non-null match values from the inner parsers.\n */\nexport function seq(...parsers) {\n  return newParser(\"seq\", {\n    cacheable: true,\n    children: parsers,\n    describe: list => \"[ \" + list.join(\", \") + \" ]\"\n  }, (state, results, ...parsers) => {\n    let commit = false;\n\n    function next(state, i, rv = []) {\n      if (i >= parsers.length) return results.add(state.success(rv, commit));\n      const p = parsers[i];\n      state.schedule(p).then(match => {\n        // no backtracking if we commit()'d in this chain.\n        if (!match.ok) return results.add(commit ? match.setCommit() : match);\n        if (match.commit) commit = true;\n        next(state.merge(match.state), i + 1, match.value != null ? rv.concat([ match.value ]) : rv);\n      });\n    }\n\n    next(state, 0);\n  });\n}\n\n/*\n * chain together a sequence of parsers. before each parser is checked, the\n * 'ignore' parser is optionally matched and thrown away. this is typicially\n * used for discarding whitespace in lexical parsing.\n */\nexport function seqIgnore(ignore, ...parsers) {\n  const newseq = [];\n  parsers.forEach(p => {\n    newseq.push(drop(optional(ignore)));\n    newseq.push(p);\n  });\n  return seq(...newseq);\n}\n\n/*\n * try each of these parsers, in order (starting from the same position),\n * looking for the first match.\n */\nexport function alt(...parsers) {\n  return newParser(\"alt\", {\n    cacheable: true,\n    children: parsers,\n    describe: list => list.join(\" or \")\n  }, (state, results, ...parsers) => {\n    let aborting = false;\n    let count = 0;\n    const fails = [];\n    parsers.forEach(p => {\n      state.schedule(p, () => !aborting).then(match => {\n        if (match.ok) {\n          results.add(match);\n        } else {\n          if (match.commit) {\n            // skip other alternatives; dump error buffer.\n            aborting = true;\n            fails.splice(0, fails.length);\n            return results.add(match);\n          }\n          fails.push(match);\n        }\n        // save up all the fails. if *all* of the alternatives fail, summarize it.\n        count++;\n        if (count == parsers.length) {\n          if (count == fails.length) {\n            results.add(state.failure());\n          } else {\n            fails.forEach(f => results.add(f));\n          }\n        }\n      });\n    });\n  });\n}\n\n/*\n * throw away the match value, equivalent to `map(null)`.\n */\nexport function drop(p) {\n  return newParser(\"drop\", { wrap: p, cacheable: true }, (state, results, p) => {\n    state.schedule(p).then(match => {\n      results.add(match.ok ? match.withValue(null) : match);\n    });\n  });\n}\n\n/*\n * allow a parser to fail, and instead return a default value (the empty string\n * if no other value is provided).\n */\nexport function optional(p, defaultValue) {\n  return newParser(\"optional\", {\n    wrap: p,\n    cacheable: (typeof defaultValue == \"string\"),\n    extraCacheKey: defaultValue\n  }, (state, results, p) => {\n    state.schedule(p).then(match => {\n      results.add(match);\n      // unless we committed to p, always try the non-p case too.\n      if (!match.commit) results.add(state.success(defaultValue));\n    });\n  });\n}\n\n/*\n * check that this parser matches, but don't advance our position in the\n * string. (perl calls this a zero-width lookahead.)\n */\nexport function check(p) {\n  return newParser(\"check\", { wrap: p, cacheable: true }, (state, results, p) => {\n    state.schedule(p).then(match => {\n      results.add(match.ok ? match.withState(state) : match);\n    });\n  });\n}\n\n/*\n * if this parser matches, \"commit\" to this path and refuse to backtrack to\n * previous alternatives.\n */\nexport function commit(p) {\n  return newParser(\"commit\", { wrap: p, cacheable: true }, (state, results, p) => {\n    state.schedule(p).then(match => {\n      results.add(match.ok ? match.setCommit() : match);\n    });\n  });\n}\n\n/*\n * succeed (with an empty match) if the inner parser fails; otherwise fail.\n */\nexport function not(p) {\n  return newParser(\"not\", { wrap: p, cacheable: true }, (state, results, p) => {\n    state.schedule(p).then(match => {\n      results.add(\n        match.ok ?\n        state.failure(null, match.commit) :\n        state.success(\"\", match.commit));\n    });\n  });\n}\n\n/*\n * from 'min' to 'max' (inclusive) repetitions of a parser, returned as an\n * array. 'max' may be omitted to mean infinity.\n */\nexport function repeat(p, options = {}) {\n  const min = options.min || 0;\n  const max = options.max || Infinity;\n  return newParser(\"repeat\", {\n     children: [ p ],\n     describe: (list) => list.join() + (max == Infinity ? `{${min}+}` : `{${min}, ${max}}`)\n  }, (state, results, p) => {\n    let count = 0;\n    let list = [];\n\n    function next(match, startingState, list = [], count = 0) {\n      if (!match.ok) {\n        // if we were committed, don't backtrack.\n        if (match.commit) return results.add(match);\n        // intentionally use the \"last good state\" from our repeating parser.\n        return results.add(count >= min ?\n          state.merge(startingState).success(list, match.commit) :\n          state.failure());\n      }\n      count++;\n      const newlist = match.value != null ? list.concat([ match.value ]) : list;\n      if (count >= min) results.add(state.merge(match.state).success(newlist, match.commit));\n      if (count < max) {\n        // if a parser matches nothing, we could go on forever...\n        if (match.state.pos == state.pos) {\n          throw new Error(`Repeating parser isn't making progress at position ${state.pos}: ${p}`);\n        }\n        match.state.schedule(p).then(m => next(m, match.state, newlist, count));\n      }\n    }\n\n    state.schedule(p).then(m => next(m, state));\n  });\n}\n\n/*\n * like 'repeat', but each element may be optionally preceded by 'ignore',\n * which will be thrown away. this is usually used to remove leading\n * whitespace.\n */\nexport function repeatIgnore(p, ignore, options) {\n  return repeat(seq(optional(ignore).drop(), p).map(x => x[0]), options);\n}\n\n/*\n * like 'repeat', but the repeated elements are separated by 'separator',\n * which is ignored.\n */\nexport function repeatSeparated(p, separator = \"\", options = {}) {\n  const min = options.min ? options.min - 1 : 0;\n  const max = options.max ? options.max - 1 : Infinity;\n  const p2 = seq(drop(separator), p).map(x => x[0]);\n  return seq(p, repeat(p2, { min, max })).map(x => {\n    return [ x[0] ].concat(x[1]);\n  });\n}\n\n/*\n * convenience method for reducing the result of 'repeatSeparated', optionally\n * keeping the separator results. if 'accumulator' exists, it will transform\n * the initial result into an accumulator. if 'reducer' exists, it will be\n * used to progressively attach separators and new results.\n */\nexport function reduce(p, separator = \"\", options = {}) {\n  const first = options.first || (x => [ x ]);\n  const next = options.next || ((sum, sep, x) => sum.push(x));\n  const min = options.min ? options.min - 1 : 0;\n  const max = options.max ? options.max - 1 : Infinity;\n\n  return seq(p, repeat(seq(separator, p), { min, max })).map(([ initial, remainder ]) => {\n    return [ first(initial) ].concat(remainder).reduce((sum, [ sep, item ]) => {\n      // 'sep' may have been dropped.\n      if (item === undefined) {\n        item = sep;\n        sep = null;\n      }\n      return next(sum, sep, item);\n    });\n  });\n}\n"]}