"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _combiners = require("./combiners");

var _engine = require("./engine");

var _engine2 = _interopRequireDefault(_engine);

var _resolve2 = require("./resolve");

var _resolve3 = _interopRequireDefault(_resolve2);

var _strings = require("./strings");

var ParserId = 1;

var __cache = {};

/*
 * create a new Parser object:
 * - name: type of parser, in one word ("alt", "optional", ...)
 * - options:
 *   - children: list of nested parsers, if this is a combiner
 *   - describe: `(children: Array(String)) => String`
 *     - returns a description of the parser for debugging, including children,
 *       like "x or y or z"
 * - matcher: `(parser, state, results) => void`
 *   - parser: effectively `this`
 *   - state: `ParserState` current text and position
 *   - results: `ResultSet` container for eventual result (success or failure)
 */
function newParser(name, options, matcher) {
  if (options === undefined) options = {};

  if (!matcher) {
    // options is optional.
    matcher = options;
    options = {};
  }

  if (options.wrap) {
    options.children = [options.wrap];
    if (!options.describe) options.describe = function (list) {
      return name + ":" + list.join();
    };
    delete options.wrap;
  }

  if (!options.describe) options.describe = name;

  var parser = new Parser(name, options.children, options.describe, matcher);
  parser.cacheable = options.cacheable;
  parser.extraCacheKey = options.extraCacheKey;
  return parser;
}

/*
 * internal use: not intended to be created by users (use `newParser` above).
 */

var Parser = (function () {
  function Parser(name, children, describe, matcher) {
    _classCallCheck(this, Parser);

    this.name = name;
    this.children = children;
    this.describe = describe;
    this.matcher = matcher;
    this.id = ParserId;
    ParserId += 1;
    // detect and avoid loops when displaying debug strings:
    this.recursing = false;
    // set when all lazy and implicit parsers have been resolved:
    this.resolved = false;
  }

  _createClass(Parser, [{
    key: "toString",
    value: function toString() {
      return "Parser[" + this.id + ", " + this.name + "]";
    }
  }, {
    key: "inspect",
    value: function inspect() {
      if (this.recursing) return "...";
      if (typeof this.describe == "string") return this.describe;
      this.recursing = true;
      this.resolve();
      var list = (this.children || []).map(function (p) {
        return p.children && p.children.length > 1 ? "(" + p.inspect() + ")" : p.inspect();
      });
      this.recursing = false;
      this.describe = this.describe(list);
      return this.describe;
    }

    // create a dot graph of the parser nesting
  }, {
    key: "toDot",
    value: function toDot() {
      var maxLength = arguments.length <= 0 || arguments[0] === undefined ? 40 : arguments[0];

      var seen = {};
      var nodes = [];
      var edges = [];

      function traverse(parser) {
        seen[parser.id] = true;
        nodes.push({ id: parser.id, name: parser.name, description: parser.inspect() });
        (parser.children || []).forEach(function (p) {
          edges.push({ from: parser.id, to: p.id });
          if (!seen[p.id]) traverse(p);
        });
      }

      this.resolve();
      traverse(this);

      var data = ["digraph packrattle {", "  node [fontname=Courier];"];
      data.push("");
      edges.forEach(function (e) {
        data.push("  \"" + e.from + "\" -> \"" + e.to + "\";");
      });
      data.push("");
      nodes.forEach(function (n) {
        var description = n.description;
        if (description.length > maxLength) description = description.slice(0, maxLength) + "...";
        description = description.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
        var name = n.name.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
        var label = "[" + n.id + "] " + name + (name == description ? "" : "\\n" + description);
        data.push("  \"" + n.id + "\" [label=\"" + label + "\", shape=rect];");
      });
      data.push("}");
      return data.join("\n") + "\n";
    }

    // helper for debugging inside node
  }, {
    key: "writeDotFile",
    value: function writeDotFile(filename, maxLength) {
      require("fs").writeFileSync(filename, this.toDot(maxLength));
    }
  }, {
    key: "resolve",
    value: function resolve() {
      var functionCache = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      // we won't perfectly cache loops, but that's fine.
      if (this.resolved) return this;
      this.resolved = true;

      if (this.children) {
        if (!functionCache) functionCache = {};
        try {
          this.children = this.children.map(function (p) {
            return (0, _resolve3["default"])(p, functionCache).resolve(functionCache);
          });
        } catch (error) {
          error.message += " (inside " + this.name + ")";
          throw error;
        }
      }

      // if this parser can be cached, do so. if one like it already exists, return that one and let this one vanish.
      this._computeCacheKey();
      if (this.cacheKey) {
        if (__cache[this.cacheKey]) return __cache[this.cacheKey];
        __cache[this.cacheKey] = this;
      }
      return this;
    }

    // computed during resolve phase.
  }, {
    key: "_computeCacheKey",
    value: function _computeCacheKey() {
      if (!this.cacheable) return null;
      if (this.cacheKey) return this.cacheKey;

      // if it's a simple parser (no children), it must have a simple string description to be cacheable.
      if (!this.children || this.children.length == 0) {
        if (!(typeof this.describe == "string")) return null;
        this.cacheKey = this.name + ":" + (0, _strings.quote)(this.describe);
        if (this.extraCacheKey) this.cacheKey += "&" + (0, _strings.quote)(this.extraCacheKey);
        return this.cacheKey;
      }

      // all children must be cacheable (and already cached).
      var ok = true;
      this.children.forEach(function (p) {
        if (!p.cacheKey) ok = false;
      });
      if (!ok) return null;
      this.cacheKey = this.name + ":" + this.children.map(function (p) {
        return (0, _strings.quote)(p.cacheKey);
      }).join("&");
      if (this.extraCacheKey) this.cacheKey += "&" + (0, _strings.quote)(this.extraCacheKey);
      return this.cacheKey;
    }
  }, {
    key: "execute",
    value: function execute(text) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      this.resolve();
      return new _engine2["default"](text, options).execute(this);
    }

    // return a parser that asserts that the string ends after this parser.
  }, {
    key: "consume",
    value: function consume() {
      // es6 still can't handle loops.
      var simple = require("./simple");
      return (0, _combiners.chain)(this, simple.end, function (a, b) {
        return a;
      });
    }

    // consume an entire text with this parser. convert failure into an exception.
  }, {
    key: "run",
    value: function run(text) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var rv = this.consume().execute(text, options);
      if (!rv.ok) {
        var error = new Error(rv.value);
        error.span = rv.state.span();
        throw error;
      }
      return rv.value;
    }

    // ----- transforms

    // transforms the result of a parser if it succeeds.
    // f(value, span)
  }, {
    key: "map",
    value: function map(f) {
      var _this = this;

      return newParser("map", { wrap: this }, function (state, results) {
        state.schedule(_this).then(function (match) {
          if (!match.ok) return results.add(match);
          if (typeof f != "function") return results.add(match.withValue(f));

          try {
            var rv = f(match.value, match.state.span());
            if (rv instanceof Parser) {
              match.state.schedule(rv).then(function (m) {
                return results.add(m);
              });
            } else {
              results.add(match.withValue(rv));
            }
          } catch (error) {
            results.add(match.toError(error.toString()));
          }
        });
      });
    }
  }, {
    key: "onMatch",
    value: function onMatch(f) {
      return this.map(f);
    }

    // transforms the error message of a parser
  }, {
    key: "onFail",
    value: function onFail(newMessage) {
      var _this2 = this;

      return newParser("onFail", { wrap: this }, function (state, results) {
        state.schedule(_this2).then(function (match) {
          results.add(match.ok ? match : match.toError(newMessage));
        });
      });
    }

    // transforms the error message of a parser, but only if it hasn't been already.
  }, {
    key: "named",
    value: function named(description) {
      var _this3 = this;

      return newParser("onFail", { wrap: this, describe: description }, function (state, results) {
        state.schedule(_this3).then(function (match) {
          results.add(match.commit ? match : match.changeGeneratedMessage("Expected " + description));
        });
      });
    }

    // only succeed if f(value, state) returns true. optional failure message.
  }, {
    key: "matchIf",
    value: function matchIf(f, message) {
      var _this4 = this;

      return newParser("filter", { wrap: this }, function (state, results) {
        state.schedule(_this4).then(function (match) {
          if (match.ok && !f(match.value, match.state.span())) {
            results.add(state.failure(message));
          } else {
            results.add(match);
          }
        });
      });
    }
  }, {
    key: "filter",
    value: function filter(f, message) {
      return this.matchIf(f, message);
    }

    // ----- convenience methods for accessing the combinators

  }, {
    key: "then",
    value: function then() {
      for (var _len = arguments.length, parsers = Array(_len), _key = 0; _key < _len; _key++) {
        parsers[_key] = arguments[_key];
      }

      return _combiners.seq.apply(undefined, [this].concat(parsers));
    }
  }, {
    key: "or",
    value: function or() {
      for (var _len2 = arguments.length, parsers = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        parsers[_key2] = arguments[_key2];
      }

      return _combiners.alt.apply(undefined, [this].concat(parsers));
    }
  }, {
    key: "drop",
    value: function drop() {
      return (0, _combiners.drop)(this);
    }
  }, {
    key: "optional",
    value: function optional() {
      var defaultValue = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];
      return (0, _combiners.optional)(this, defaultValue);
    }
  }, {
    key: "check",
    value: function check() {
      return (0, _combiners.check)(this);
    }
  }, {
    key: "commit",
    value: function commit() {
      return (0, _combiners.commit)(this);
    }
  }, {
    key: "not",
    value: function not() {
      return (0, _combiners.not)(this);
    }
  }, {
    key: "repeat",
    value: function repeat(options) {
      return (0, _combiners.repeat)(this, options);
    }
  }, {
    key: "times",
    value: function times(count) {
      return (0, _combiners.repeat)(this, { min: count, max: count });
    }
  }]);

  return Parser;
})();

exports.newParser = newParser;
exports.Parser = Parser;
//# sourceMappingURL=parser.js.map