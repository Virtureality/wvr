"use strict";

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _lib = require("../../lib");

var _lib2 = _interopRequireDefault(_lib);

require("should");
require("source-map-support").install();

describe("Parser.map", function () {
  it("transforms a match", function () {
    var p = (0, _lib2["default"])("hello").map(function (value, state) {
      return [value.toUpperCase(), state.start, state.end];
    });
    (function () {
      return p.run("cat");
    }).should["throw"](/hello/);
    p.execute("hellon").value.should.eql(["HELLO", 0, 5]);
  });

  it("transforms a match into a constant", function () {
    var p = (0, _lib2["default"])("hello").map("yes");
    var rv = p.execute("hello");
    rv.value.should.eql("yes");
    rv.state.pos.should.equal(5);
  });

  it("transforms a match into a failure on exception", function () {
    var p = (0, _lib2["default"])("hello").map(function (value) {
      throw new Error("utter failure");
    });
    (function () {
      return p.run("hello");
    }).should["throw"](/utter failure/);
  });

  it("onFail", function () {
    var p = (0, _lib.string)("hello").onFail("Try a greeting.");
    (function () {
      return p.run("cat");
    }).should["throw"]("Try a greeting.");
    p.execute("hellon").value.should.eql("hello");
  });

  // ----- monad tests

  var a = "foo";
  var m = (0, _lib2["default"])("foo");
  var f = function f(s) {
    return (0, _lib2["default"])(s + "bar");
  };
  var g = function g(s) {
    return (0, _lib2["default"])(s + "baz");
  };

  function shouldBeIdentical(p1, p2, input) {
    var rv1 = p1.execute(input);
    var rv2 = p2.execute(input);
    rv1.ok.should.equal(true);
    rv2.ok.should.equal(true);
    rv1.value.should.equal(rv2.value);
  }

  it("satisfies monad left identity", function () {
    var p1 = _lib2["default"].succeed(a).map(f);
    var p2 = f(a);
    shouldBeIdentical(p1, p2, "foobar");
  });

  it("satisfies monad right identity", function () {
    var p1 = m.map(_lib2["default"].succeed);
    var p2 = m;
    shouldBeIdentical(p1, p2, "foo");
  });

  it("satisfies monad associativity", function () {
    var p1 = m.map(f).map(g);
    var p2 = m.map(function (s) {
      return f(s).map(g);
    });
    shouldBeIdentical(p1, p2, "foofoobarfoobarbaz");
  });

  it("fails if a nested parser fails", function () {
    var p = m.map(function () {
      return _lib2["default"].reject.onFail("no foo");
    });
    var rv = p.execute("foo");
    rv.ok.should.equal(false);
    rv.value.should.equal("no foo");
  });
});
//# sourceMappingURL=test_map.js.map