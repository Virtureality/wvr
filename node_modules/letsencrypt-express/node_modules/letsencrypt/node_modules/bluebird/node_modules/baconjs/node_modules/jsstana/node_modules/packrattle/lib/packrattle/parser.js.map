{"version":3,"sources":["../../src/packrattle/parser.js"],"names":[],"mappings":"AAAA,YAAY,CAAC;;;;;;;;yBAE+D,aAAa;;sBACtE,UAAU;;;;wBACT,WAAW;;;;uBACT,WAAW;;AAEjC,IAAI,QAAQ,GAAG,CAAC,CAAC;;AAEjB,IAAM,OAAO,GAAG,EAAE,CAAC;;;;;;;;;;;;;;;AAenB,SAAS,SAAS,CAAC,IAAI,EAAE,OAAO,EAAO,OAAO,EAAE;MAAvB,OAAO,gBAAP,OAAO,GAAG,EAAE;;AACnC,MAAI,CAAC,OAAO,EAAE;;AAEZ,WAAO,GAAG,OAAO,CAAC;AAClB,WAAO,GAAG,EAAE,CAAC;GACd;;AAED,MAAI,OAAO,CAAC,IAAI,EAAE;AAChB,WAAO,CAAC,QAAQ,GAAG,CAAE,OAAO,CAAC,IAAI,CAAE,CAAC;AACpC,QAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,QAAQ,GAAG,UAAA,IAAI;aAAI,IAAI,GAAG,GAAG,GAAG,IAAI,CAAC,IAAI,EAAE;KAAA,CAAC;AAC3E,WAAO,OAAO,CAAC,IAAI,CAAC;GACrB;;AAED,MAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,QAAQ,GAAG,IAAI,CAAC;;AAE/C,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;AAC7E,QAAM,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;AACrC,QAAM,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC;AAC7C,SAAO,MAAM,CAAC;CACf;;;;;;IAMK,MAAM;AACC,WADP,MAAM,CACE,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE;0BAD3C,MAAM;;AAER,QAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACjB,QAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AACzB,QAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AACzB,QAAI,CAAC,OAAO,GAAG,OAAO,CAAC;AACvB,QAAI,CAAC,EAAE,GAAG,QAAQ,CAAC;AACnB,YAAQ,IAAI,CAAC,CAAC;;AAEd,QAAI,CAAC,SAAS,GAAG,KAAK,CAAC;;AAEvB,QAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;GACvB;;eAZG,MAAM;;WAcF,oBAAG;AACT,yBAAiB,IAAI,CAAC,EAAE,UAAK,IAAI,CAAC,IAAI,OAAI;KAC3C;;;WAEM,mBAAG;AACR,UAAI,IAAI,CAAC,SAAS,EAAE,OAAO,KAAK,CAAC;AACjC,UAAI,OAAO,IAAI,CAAC,QAAQ,IAAI,QAAQ,EAAE,OAAO,IAAI,CAAC,QAAQ,CAAC;AAC3D,UAAI,CAAC,SAAS,GAAG,IAAI,CAAC;AACtB,UAAI,CAAC,OAAO,EAAE,CAAC;AACf,UAAM,IAAI,GAAG,CAAC,IAAI,CAAC,QAAQ,IAAI,EAAE,CAAA,CAAE,GAAG,CAAC,UAAA,CAAC,EAAI;AAC1C,eAAO,AAAC,CAAC,CAAC,QAAQ,IAAI,CAAC,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,GAAK,GAAG,GAAG,CAAC,CAAC,OAAO,EAAE,GAAG,GAAG,GAAI,CAAC,CAAC,OAAO,EAAE,CAAC;OACxF,CAAC,CAAC;AACH,UAAI,CAAC,SAAS,GAAG,KAAK,CAAC;AACvB,UAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;AACpC,aAAO,IAAI,CAAC,QAAQ,CAAC;KACtB;;;;;WAGI,iBAAiB;UAAhB,SAAS,yDAAG,EAAE;;AAClB,UAAM,IAAI,GAAG,EAAE,CAAC;AAChB,UAAM,KAAK,GAAG,EAAE,CAAC;AACjB,UAAM,KAAK,GAAG,EAAE,CAAC;;AAEjB,eAAS,QAAQ,CAAC,MAAM,EAAE;AACxB,YAAI,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC;AACvB,aAAK,CAAC,IAAI,CAAC,EAAE,EAAE,EAAE,MAAM,CAAC,EAAE,EAAE,IAAI,EAAE,MAAM,CAAC,IAAI,EAAE,WAAW,EAAE,MAAM,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;AAChF,SAAC,MAAM,CAAC,QAAQ,IAAI,EAAE,CAAA,CAAE,OAAO,CAAC,UAAA,CAAC,EAAI;AACnC,eAAK,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,MAAM,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;AAC1C,cAAI,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;SAC9B,CAAC,CAAC;OACJ;;AAED,UAAI,CAAC,OAAO,EAAE,CAAC;AACf,cAAQ,CAAC,IAAI,CAAC,CAAC;;AAEf,UAAM,IAAI,GAAG,CACX,sBAAsB,EACtB,4BAA4B,CAC7B,CAAC;AACF,UAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;AACd,WAAK,CAAC,OAAO,CAAC,UAAA,CAAC,EAAI;AACjB,YAAI,CAAC,IAAI,UAAO,CAAC,CAAC,IAAI,gBAAS,CAAC,CAAC,EAAE,SAAK,CAAC;OAC1C,CAAC,CAAC;AACH,UAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;AACd,WAAK,CAAC,OAAO,CAAC,UAAA,CAAC,EAAI;AACjB,YAAI,WAAW,GAAG,CAAC,CAAC,WAAW,CAAC;AAChC,YAAI,WAAW,CAAC,MAAM,GAAG,SAAS,EAAE,WAAW,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE,SAAS,CAAC,GAAG,KAAK,CAAC;AAC1F,mBAAW,GAAG,WAAW,CAAC,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;AACvE,YAAM,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;AACjE,YAAM,KAAK,GAAG,MAAI,CAAC,CAAC,EAAE,UAAK,IAAI,IAAM,IAAI,IAAI,WAAW,GAAG,EAAE,GAAG,KAAK,GAAG,WAAW,CAAA,AAAC,CAAC;AACrF,YAAI,CAAC,IAAI,UAAO,CAAC,CAAC,EAAE,oBAAa,KAAK,sBAAkB,CAAC;OAC1D,CAAC,CAAC;AACH,UAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACf,aAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;KAC/B;;;;;WAGW,sBAAC,QAAQ,EAAE,SAAS,EAAE;AAChC,aAAO,CAAC,IAAI,CAAC,CAAC,aAAa,CAAC,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC;KAC9D;;;WAEM,mBAAuB;UAAtB,aAAa,yDAAG,IAAI;;;AAE1B,UAAI,IAAI,CAAC,QAAQ,EAAE,OAAO,IAAI,CAAC;AAC/B,UAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;;AAErB,UAAI,IAAI,CAAC,QAAQ,EAAE;AACjB,YAAI,CAAC,aAAa,EAAE,aAAa,GAAG,EAAE,CAAC;AACvC,YAAI;AACF,cAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAA,CAAC;mBAAI,0BAAQ,CAAC,EAAE,aAAa,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC;WAAA,CAAC,CAAC;SAC1F,CAAC,OAAO,KAAK,EAAE;AACd,eAAK,CAAC,OAAO,IAAI,WAAW,GAAG,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC;AAC/C,gBAAM,KAAK,CAAC;SACb;OACF;;;AAGD,UAAI,CAAC,gBAAgB,EAAE,CAAC;AACxB,UAAI,IAAI,CAAC,QAAQ,EAAE;AACjB,YAAI,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,OAAO,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AAC1D,eAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC;OAC/B;AACD,aAAO,IAAI,CAAC;KACb;;;;;WAGe,4BAAG;AACjB,UAAI,CAAC,IAAI,CAAC,SAAS,EAAE,OAAO,IAAI,CAAC;AACjC,UAAI,IAAI,CAAC,QAAQ,EAAE,OAAO,IAAI,CAAC,QAAQ,CAAC;;;AAGxC,UAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,IAAI,CAAC,EAAE;AAC/C,YAAI,EAAE,OAAO,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAA,AAAC,EAAE,OAAO,IAAI,CAAC;AACrD,YAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,IAAI,GAAG,GAAG,GAAG,aAvJ/B,KAAK,EAuJgC,IAAI,CAAC,QAAQ,CAAC,CAAC;AACvD,YAAI,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,QAAQ,IAAI,GAAG,GAAG,aAxJ5C,KAAK,EAwJ6C,IAAI,CAAC,aAAa,CAAC,CAAC;AACzE,eAAO,IAAI,CAAC,QAAQ,CAAC;OACtB;;;AAGD,UAAI,EAAE,GAAG,IAAI,CAAC;AACd,UAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,UAAA,CAAC,EAAI;AACzB,YAAI,CAAC,CAAC,CAAC,QAAQ,EAAE,EAAE,GAAG,KAAK,CAAC;OAC7B,CAAC,CAAC;AACH,UAAI,CAAC,EAAE,EAAE,OAAO,IAAI,CAAC;AACrB,UAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,IAAI,GAAG,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAA,CAAC;eAAI,aAlKpD,KAAK,EAkKqD,CAAC,CAAC,QAAQ,CAAC;OAAA,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACtF,UAAI,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,QAAQ,IAAI,GAAG,GAAG,aAnK1C,KAAK,EAmK2C,IAAI,CAAC,aAAa,CAAC,CAAC;AACzE,aAAO,IAAI,CAAC,QAAQ,CAAC;KACtB;;;WAEM,iBAAC,IAAI,EAAgB;UAAd,OAAO,yDAAG,EAAE;;AACxB,UAAI,CAAC,OAAO,EAAE,CAAC;AACf,aAAO,wBAAW,IAAI,EAAE,OAAO,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAChD;;;;;WAGM,mBAAG;;AAER,UAAM,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;AACnC,aAAO,eAnLG,KAAK,EAmLF,IAAI,EAAE,MAAM,CAAC,GAAG,EAAE,UAAC,CAAC,EAAE,CAAC;eAAK,CAAC;OAAA,CAAC,CAAC;KAC7C;;;;;WAGE,aAAC,IAAI,EAAgB;UAAd,OAAO,yDAAG,EAAE;;AACpB,UAAM,EAAE,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;AACjD,UAAI,CAAC,EAAE,CAAC,EAAE,EAAE;AACV,YAAM,KAAK,GAAG,IAAI,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC;AAClC,aAAK,CAAC,IAAI,GAAG,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;AAC7B,cAAM,KAAK,CAAC;OACb;AACD,aAAO,EAAE,CAAC,KAAK,CAAC;KACjB;;;;;;;;WAME,aAAC,CAAC,EAAE;;;AACL,aAAO,SAAS,CAAC,KAAK,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,UAAC,KAAK,EAAE,OAAO,EAAK;AAC1D,aAAK,CAAC,QAAQ,OAAM,CAAC,IAAI,CAAC,UAAA,KAAK,EAAI;AACjC,cAAI,CAAC,KAAK,CAAC,EAAE,EAAE,OAAO,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AACzC,cAAI,OAAO,CAAC,IAAI,UAAU,EAAE,OAAO,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;;AAEnE,cAAI;AACF,gBAAM,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC;AAC9C,gBAAI,EAAE,YAAY,MAAM,EAAE;AACxB,mBAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,UAAA,CAAC;uBAAI,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;eAAA,CAAC,CAAC;aACpD,MAAM;AACL,qBAAO,CAAC,GAAG,CAAC,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC;aAClC;WACF,CAAC,OAAO,KAAK,EAAE;AACd,mBAAO,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;WAC9C;SACF,CAAC,CAAC;OACJ,CAAC,CAAC;KACJ;;;WAEM,iBAAC,CAAC,EAAE;AAAE,aAAO,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;KAAE;;;;;WAG5B,gBAAC,UAAU,EAAE;;;AACjB,aAAO,SAAS,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,UAAC,KAAK,EAAE,OAAO,EAAK;AAC7D,aAAK,CAAC,QAAQ,QAAM,CAAC,IAAI,CAAC,UAAA,KAAK,EAAI;AACjC,iBAAO,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,GAAG,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC;SAC3D,CAAC,CAAC;OACJ,CAAC,CAAC;KACJ;;;;;WAGI,eAAC,WAAW,EAAE;;;AACjB,aAAO,SAAS,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,EAAE,UAAC,KAAK,EAAE,OAAO,EAAK;AACpF,aAAK,CAAC,QAAQ,QAAM,CAAC,IAAI,CAAC,UAAA,KAAK,EAAI;AACjC,iBAAO,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,GACtB,KAAK,GACL,KAAK,CAAC,sBAAsB,CAAC,WAAW,GAAG,WAAW,CAAC,CACxD,CAAC;SACH,CAAC,CAAC;OACJ,CAAC,CAAC;KACJ;;;;;WAGM,iBAAC,CAAC,EAAE,OAAO,EAAE;;;AAClB,aAAO,SAAS,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,UAAC,KAAK,EAAE,OAAO,EAAK;AAC7D,aAAK,CAAC,QAAQ,QAAM,CAAC,IAAI,CAAC,UAAA,KAAK,EAAI;AACjC,cAAI,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,EAAE;AACnD,mBAAO,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;WACrC,MAAM;AACL,mBAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;WACpB;SACF,CAAC,CAAC;OACJ,CAAC,CAAC;KACJ;;;WAEK,gBAAC,CAAC,EAAE,OAAO,EAAE;AAAE,aAAO,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;KAAE;;;;;;WAKnD,gBAAa;wCAAT,OAAO;AAAP,eAAO;;;AAAI,aAAO,WAlQqC,GAAG,mBAkQpC,IAAI,SAAK,OAAO,EAAC,CAAC;KAAE;;;WAEhD,cAAa;yCAAT,OAAO;AAAP,eAAO;;;AAAI,aAAO,WApQjB,GAAG,mBAoQkB,IAAI,SAAK,OAAO,EAAC,CAAC;KAAE;;;WAE5C,gBAAG;AAAE,aAAO,eAtQkB,IAAI,EAsQjB,IAAI,CAAC,CAAC;KAAE;;;WAErB,oBAAoB;UAAnB,YAAY,yDAAG,EAAE;AAAI,aAAO,eAxQQ,QAAQ,EAwQP,IAAI,EAAE,YAAY,CAAC,CAAC;KAAE;;;WAE/D,iBAAG;AAAE,aAAO,eA1QE,KAAK,EA0QD,IAAI,CAAC,CAAC;KAAE;;;WAEzB,kBAAG;AAAE,aAAO,eA5QQ,MAAM,EA4QP,IAAI,CAAC,CAAC;KAAE;;;WAE9B,eAAG;AAAE,aAAO,eA9QyB,GAAG,EA8QxB,IAAI,CAAC,CAAC;KAAE;;;WAErB,gBAAC,OAAO,EAAE;AAAE,aAAO,eAhR8B,MAAM,EAgR7B,IAAI,EAAE,OAAO,CAAC,CAAC;KAAE;;;WAE5C,eAAC,KAAK,EAAE;AAAE,aAAO,eAlRiC,MAAM,EAkRhC,IAAI,EAAE,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,CAAC,CAAC;KAAE;;;SAnO7D,MAAM;;;AAuOZ,OAAO,CAAC,SAAS,GAAG,SAAS,CAAC;AAC9B,OAAO,CAAC,MAAM,GAAG,MAAM,CAAC","file":"parser.js","sourcesContent":["\"use strict\";\n\nimport { alt, chain, check, commit, drop, not, optional, repeat, seq } from \"./combiners\";\nimport Engine from \"./engine\";\nimport resolve from \"./resolve\";\nimport { quote } from \"./strings\";\n\nlet ParserId = 1;\n\nconst __cache = {};\n\n/*\n * create a new Parser object:\n * - name: type of parser, in one word (\"alt\", \"optional\", ...)\n * - options:\n *   - children: list of nested parsers, if this is a combiner\n *   - describe: `(children: Array(String)) => String`\n *     - returns a description of the parser for debugging, including children,\n *       like \"x or y or z\"\n * - matcher: `(parser, state, results) => void`\n *   - parser: effectively `this`\n *   - state: `ParserState` current text and position\n *   - results: `ResultSet` container for eventual result (success or failure)\n */\nfunction newParser(name, options = {}, matcher) {\n  if (!matcher) {\n    // options is optional.\n    matcher = options;\n    options = {};\n  }\n\n  if (options.wrap) {\n    options.children = [ options.wrap ];\n    if (!options.describe) options.describe = list => name + \":\" + list.join();\n    delete options.wrap;\n  }\n\n  if (!options.describe) options.describe = name;\n\n  const parser = new Parser(name, options.children, options.describe, matcher);\n  parser.cacheable = options.cacheable;\n  parser.extraCacheKey = options.extraCacheKey;\n  return parser;\n}\n\n\n/*\n * internal use: not intended to be created by users (use `newParser` above).\n */\nclass Parser {\n  constructor(name, children, describe, matcher) {\n    this.name = name;\n    this.children = children;\n    this.describe = describe;\n    this.matcher = matcher;\n    this.id = ParserId;\n    ParserId += 1;\n    // detect and avoid loops when displaying debug strings:\n    this.recursing = false;\n    // set when all lazy and implicit parsers have been resolved:\n    this.resolved = false;\n  }\n\n  toString() {\n    return `Parser[${this.id}, ${this.name}]`;\n  }\n\n  inspect() {\n    if (this.recursing) return \"...\";\n    if (typeof this.describe == \"string\") return this.describe;\n    this.recursing = true;\n    this.resolve();\n    const list = (this.children || []).map(p => {\n      return (p.children && p.children.length > 1) ? (\"(\" + p.inspect() + \")\") : p.inspect();\n    });\n    this.recursing = false;\n    this.describe = this.describe(list);\n    return this.describe;\n  }\n\n  // create a dot graph of the parser nesting\n  toDot(maxLength = 40) {\n    const seen = {};\n    const nodes = [];\n    const edges = [];\n\n    function traverse(parser) {\n      seen[parser.id] = true;\n      nodes.push({ id: parser.id, name: parser.name, description: parser.inspect() });\n      (parser.children || []).forEach(p => {\n        edges.push({ from: parser.id, to: p.id });\n        if (!seen[p.id]) traverse(p);\n      });\n    }\n\n    this.resolve();\n    traverse(this);\n\n    const data = [\n      \"digraph packrattle {\",\n      \"  node [fontname=Courier];\"\n    ];\n    data.push(\"\");\n    edges.forEach(e => {\n      data.push(`  \"${e.from}\" -> \"${e.to}\";`);\n    });\n    data.push(\"\");\n    nodes.forEach(n => {\n      let description = n.description;\n      if (description.length > maxLength) description = description.slice(0, maxLength) + \"...\";\n      description = description.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\");\n      const name = n.name.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\");\n      const label = `[${n.id}] ${name}` + (name == description ? \"\" : \"\\\\n\" + description);\n      data.push(`  \"${n.id}\" [label=\"${label}\", shape=rect];`);\n    });\n    data.push(\"}\");\n    return data.join(\"\\n\") + \"\\n\";\n  }\n\n  // helper for debugging inside node\n  writeDotFile(filename, maxLength) {\n    require(\"fs\").writeFileSync(filename, this.toDot(maxLength));\n  }\n\n  resolve(functionCache = null) {\n    // we won't perfectly cache loops, but that's fine.\n    if (this.resolved) return this;\n    this.resolved = true;\n\n    if (this.children) {\n      if (!functionCache) functionCache = {};\n      try {\n        this.children = this.children.map(p => resolve(p, functionCache).resolve(functionCache));\n      } catch (error) {\n        error.message += \" (inside \" + this.name + \")\";\n        throw error;\n      }\n    }\n\n    // if this parser can be cached, do so. if one like it already exists, return that one and let this one vanish.\n    this._computeCacheKey();\n    if (this.cacheKey) {\n      if (__cache[this.cacheKey]) return __cache[this.cacheKey];\n      __cache[this.cacheKey] = this;\n    }\n    return this;\n  }\n\n  // computed during resolve phase.\n  _computeCacheKey() {\n    if (!this.cacheable) return null;\n    if (this.cacheKey) return this.cacheKey;\n\n    // if it's a simple parser (no children), it must have a simple string description to be cacheable.\n    if (!this.children || this.children.length == 0) {\n      if (!(typeof this.describe == \"string\")) return null;\n      this.cacheKey = this.name + \":\" + quote(this.describe);\n      if (this.extraCacheKey) this.cacheKey += \"&\" + quote(this.extraCacheKey);\n      return this.cacheKey;\n    }\n\n    // all children must be cacheable (and already cached).\n    let ok = true;\n    this.children.forEach(p => {\n      if (!p.cacheKey) ok = false;\n    });\n    if (!ok) return null;\n    this.cacheKey = this.name + \":\" + this.children.map(p => quote(p.cacheKey)).join(\"&\");\n    if (this.extraCacheKey) this.cacheKey += \"&\" + quote(this.extraCacheKey);\n    return this.cacheKey;\n  }\n\n  execute(text, options = {}) {\n    this.resolve();\n    return new Engine(text, options).execute(this);\n  }\n\n  // return a parser that asserts that the string ends after this parser.\n  consume() {\n    // es6 still can't handle loops.\n    const simple = require(\"./simple\");\n    return chain(this, simple.end, (a, b) => a);\n  }\n\n  // consume an entire text with this parser. convert failure into an exception.\n  run(text, options = {}) {\n    const rv = this.consume().execute(text, options);\n    if (!rv.ok) {\n      const error = new Error(rv.value);\n      error.span = rv.state.span();\n      throw error;\n    }\n    return rv.value;\n  }\n\n  // ----- transforms\n\n  // transforms the result of a parser if it succeeds.\n  // f(value, span)\n  map(f) {\n    return newParser(\"map\", { wrap: this }, (state, results) => {\n      state.schedule(this).then(match => {\n        if (!match.ok) return results.add(match);\n        if (typeof f != \"function\") return results.add(match.withValue(f));\n\n        try {\n          const rv = f(match.value, match.state.span());\n          if (rv instanceof Parser) {\n            match.state.schedule(rv).then(m => results.add(m));\n          } else {\n            results.add(match.withValue(rv));\n          }\n        } catch (error) {\n          results.add(match.toError(error.toString()));\n        }\n      });\n    });\n  }\n\n  onMatch(f) { return this.map(f); }\n\n  // transforms the error message of a parser\n  onFail(newMessage) {\n    return newParser(\"onFail\", { wrap: this }, (state, results) => {\n      state.schedule(this).then(match => {\n        results.add(match.ok ? match : match.toError(newMessage));\n      });\n    });\n  }\n\n  // transforms the error message of a parser, but only if it hasn't been already.\n  named(description) {\n    return newParser(\"onFail\", { wrap: this, describe: description }, (state, results) => {\n      state.schedule(this).then(match => {\n        results.add(match.commit ?\n          match :\n          match.changeGeneratedMessage(\"Expected \" + description)\n        );\n      });\n    });\n  }\n\n  // only succeed if f(value, state) returns true. optional failure message.\n  matchIf(f, message) {\n    return newParser(\"filter\", { wrap: this }, (state, results) => {\n      state.schedule(this).then(match => {\n        if (match.ok && !f(match.value, match.state.span())) {\n          results.add(state.failure(message));\n        } else {\n          results.add(match);\n        }\n      });\n    });\n  }\n\n  filter(f, message) { return this.matchIf(f, message); }\n\n\n  // ----- convenience methods for accessing the combinators\n\n  then(...parsers) { return seq(this, ...parsers); }\n\n  or(...parsers) { return alt(this, ...parsers); }\n\n  drop() { return drop(this); }\n\n  optional(defaultValue = \"\") { return optional(this, defaultValue); }\n\n  check() { return check(this); }\n\n  commit() { return commit(this); }\n\n  not() { return not(this); }\n\n  repeat(options) { return repeat(this, options); }\n\n  times(count) { return repeat(this, { min: count, max: count }); }\n}\n\n\nexports.newParser = newParser;\nexports.Parser = Parser;\n"]}