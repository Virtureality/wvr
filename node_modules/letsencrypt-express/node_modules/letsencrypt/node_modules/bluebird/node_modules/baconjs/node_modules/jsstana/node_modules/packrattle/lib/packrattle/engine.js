"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _debug_graph = require("./debug_graph");

var _debug_graph2 = _interopRequireDefault(_debug_graph);

var _parser_state = require("./parser_state");

var _priority_queue = require("./priority_queue");

var _priority_queue2 = _interopRequireDefault(_priority_queue);

var _promise_set = require("./promise_set");

var _promise_set2 = _interopRequireDefault(_promise_set);

var _strings = require("./strings");

/*
 * an Engine processes a string through a tree of parsers, tracking state
 * is it goes for debugging.
 */

var Engine = (function () {
  function Engine(text) {
    var _this = this;

    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, Engine);

    this.text = text;
    this["debugger"] = options["debugger"];
    if (typeof this["debugger"] == "string") {
      (function () {
        var f = require("fs").openSync(_this["debugger"], "w");
        _this["debugger"] = function (text) {
          return require("fs").writeSync(f, text + "\n");
        };
      })();
    }
    if (options.dotfile) {
      this.dotfile = typeof options.dotfile == "string" ? function (data) {
        return require("fs").writeFileSync(options.dotfile, data);
      } : options.dotfile;
      this.debugGraph = options.debugGraph || new _debug_graph2["default"]();
    }

    // queue contains items of { parser: Parser, state: ParserState, results: PromiseSet }.
    this.workQueue = new _priority_queue2["default"]();

    // cache of (parser, position) -> PromiseSet
    this.cache = {};

    // how many parsers have we run?
    this.ticks = 0;

    // track the currently-executing state for debugging (so we can graph the flow on request)
    this.currentState = null;
  }

  /*
   * schedule a parser to be executed at a given state.
   * returns a PromiseSet which should eventually hold the result.
   * (if this parser/state has already run or been scheduled, the existing
   * PromiseSet will be returned.)
   */

  _createClass(Engine, [{
    key: "schedule",
    value: function schedule(state, condition) {
      var _this2 = this;

      // skip if we've already done or scheduled this one.
      if (this.cache[state.id]) return this.cache[state.id];

      var results = new _promise_set2["default"]({
        "debugger": this["debugger"] ? function (line) {
          return _this2["debugger"]("-> " + state.id + " = " + line);
        } : null
      });
      this.cache[state.id] = results;

      if (this.debugGraph) {
        this.debugGraph.addNode(state.id, state.parser, state.span());
        this.debugGraph.addEdge(this.currentState.id, state.id);
      }

      if (this["debugger"]) this["debugger"]("schedule: " + state.id + " " + state.parser.inspect());
      this.workQueue.put({ state: state, results: results }, state.depth, condition);
      return results;
    }

    // execute a parser over a string.
  }, {
    key: "execute",
    value: function execute(parser) {
      var _this3 = this;

      var state = (0, _parser_state.newParserState)(this);
      var successes = [];
      var failures = [];

      this.currentState = state;
      if (this["debugger"]) this["debugger"]("Try '" + (0, _strings.quote)(this.text) + "' in " + parser.inspect());
      this.schedule(state.next(parser)).then(function (match) {
        if (match.ok) {
          if (_this3["debugger"]) _this3["debugger"]("-> SUCCESS: " + match);
          if (_this3.debugGraph) _this3.debugGraph.addEdge(match.state.id, "success");
          successes.push(match);
        } else {
          if (_this3["debugger"]) _this3["debugger"]("-> FAILURE: " + match);
          if (_this3.debugGraph) _this3.debugGraph.markFailure(match.state.id);
          //this.debugGraph.addEdge(match.state.id, "failure");
          failures.push(match);
        }
      });

      // start the engine!
      while (!this.workQueue.isEmpty && successes.length == 0) {
        var _state$parser;

        var _workQueue$get = this.workQueue.get();

        var _state = _workQueue$get.state;
        var results = _workQueue$get.results;

        this.ticks++;
        this.currentState = _state;
        if (this["debugger"]) this["debugger"](rpad(this.ticks, 4) + ". [" + _state.parser.id + "]" + _state.parser.inspect() + " @ " + _state.toString());

        (_state$parser = _state.parser).matcher.apply(_state$parser, [_state, results].concat(_toConsumableArray(_state.parser.children || [])));
      }

      this.currentState = null;

      // message with 'commit' set has highest priority. secondary sort by depth.
      failures.sort(function (a, b) {
        return a.commit != b.commit ? b.commit ? 1 : -1 : b.state.startpos - a.state.startpos;
      });

      if (this["debugger"]) {
        if (successes.length > 0) {
          this["debugger"]("### successes:");
          successes.forEach(function (x) {
            return _this3["debugger"]("    " + x.toString());
          });
        } else {
          this["debugger"]("### failures:");
          failures.forEach(function (x) {
            return _this3["debugger"]("    " + x.toString());
          });
        }
      }

      if (this.dotfile) this.dotfile(this.debugGraph.toDot());

      return successes.length > 0 ? successes[0] : failures[0];
    }
  }]);

  return Engine;
})();

exports["default"] = Engine;

function rpad(s, n) {
  s = s.toString();
  while (s.length < n) s = " " + s;
  return s;
}
module.exports = exports["default"];
//# sourceMappingURL=engine.js.map