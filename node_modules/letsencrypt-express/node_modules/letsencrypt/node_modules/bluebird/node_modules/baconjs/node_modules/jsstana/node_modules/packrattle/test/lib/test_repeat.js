"use strict";

var pr = require("../../lib");
var util = require("util");

require("should");
require("source-map-support").install();

function matchSpan(m) {
  var span = m.state.span();
  return [m.value, span.start, span.end];
}

describe("Parser.repeat", function () {
  it("0 or more", function () {
    var p = pr.repeat("hi");
    matchSpan(p.consume().execute("")).should.eql([[], 0, 1]);
    matchSpan(p.consume().execute("hi")).should.eql([["hi"], 0, 2]);
    matchSpan(p.consume().execute("hihihi")).should.eql([["hi", "hi", "hi"], 0, 6]);
  });

  it("2 or 3", function () {
    var p = pr.repeat("hi", { min: 2, max: 3 });
    (function () {
      return p.run("hi");
    }).should["throw"](/'hi'\{2, 3}/);
    matchSpan(p.consume().execute("hihi")).should.eql([["hi", "hi"], 0, 4]);
    matchSpan(p.consume().execute("hihihi")).should.eql([["hi", "hi", "hi"], 0, 6]);
    (function () {
      return p.run("hihihihi");
    }).should["throw"](/end/);
  });

  it("isn't always greedy", function () {
    var p = pr([pr.repeat("hi"), "hip"]);
    p.run("hihihip").should.eql([["hi", "hi"], "hip"]);
  });

  it("nested", function () {
    var p = pr([pr.repeat(["hi", pr.repeat("!")]), /[x]+/]).map(function (match) {
      return match[0];
    });
    var rv = p.consume().execute("hi!hi!!!hix");
    rv.state.pos.should.equal(11);
    rv.value.should.eql([["hi", ["!"]], ["hi", ["!", "!", "!"]], ["hi", []]]);
  });

  it("with whitespace ignoring", function () {
    var p = pr([pr.repeatIgnore("hi", /\s+/), "!"]).map(function (match) {
      return match[0];
    });
    matchSpan(p.execute("hi  hihi!")).should.eql([["hi", "hi", "hi"], 0, 9]);
  });

  it("and honors nested drops", function () {
    var p = pr("123").drop().repeat();
    var rv = p.execute("123123");
    rv.ok.should.equal(true);
    rv.value.should.eql([]);
    p = pr("123").drop().times(2);
    rv = p.execute("123123");
    rv.ok.should.equal(true);
    rv.value.should.eql([]);
  });

  it("but throws an error if there's no progress", function () {
    var p = pr.repeat("");
    (function () {
      return p.execute("?");
    }).should["throw"](/isn't making progress/);
  });

  it("repeatSeparated too", function () {
    var p = pr.repeatSeparated(pr(/\d+/).map(function (m) {
      return m[0];
    }), ",", { min: 1, max: 3 }).consume();
    matchSpan(p.execute("3")).should.eql([["3"], 0, 1]);
    (function () {
      return p.run("3,");
    }).should["throw"](/end/);
    matchSpan(p.execute("3,4")).should.eql([["3", "4"], 0, 3]);
    matchSpan(p.execute("3,40")).should.eql([["3", "40"], 0, 4]);
    matchSpan(p.execute("3,40,5")).should.eql([["3", "40", "5"], 0, 6]);
    (function () {
      return p.run("3,40,5,6");
    }).should["throw"](/end/);
  });

  it("aborts if a repeating phrase aborts", function () {
    var ws = pr(/\s*/).drop();
    var operand = pr(/\d+/).onMatch(function (m) {
      return m[0];
    }).onFail("Expected operand");
    var operator = pr([ws, pr.alt("+", "-"), ws]).commit().onMatch(function (m) {
      return m[0];
    });
    var algebra = pr.reduce(operand, operator, {
      first: function first(x) {
        return x;
      },
      next: function next(left, op, right) {
        return { binary: op, left: left, right: right };
      }
    });

    algebra.run("3 + 2").should.eql({ binary: "+", left: "3", right: "2" });

    try {
      algebra.run("3 +");
      throw new Error("nope");
    } catch (error) {
      error.message.should.eql("Expected operand");
      error.span.start.should.eql(3);
      error.span.end.should.eql(4);
    }

    try {
      algebra.run("3 + 5 +");
      throw new Error("nope");
    } catch (error) {
      error.message.should.eql("Expected operand");
      error.span.start.should.eql(7);
      error.span.end.should.eql(8);
    }
  });
});
//# sourceMappingURL=test_repeat.js.map